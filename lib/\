package lib

import (
    "fmt"
    "os"
    "log"
    "encoding/binary"
)

func WaveHello() {
    fmt.Println("hi from wave")
}


func ReadWav(filepath string) {
    wavfile, err := os.Open(filepath)
    if err != nil {
        log.Fatal(err)
    }
    defer wavfile.Close()


    header_buf := make([]byte, 44)

    n, err := wavfile.Read(header_buf)

    if n != 44 {
        log.Fatal("Fatal: .wav read failure")
    }

    //byte info from https://docs.fileformat.com/audio/wav/

    fmt.Println(header_buf)
    mark := string(header_buf[0:5])                             // RIFF File marker 
    fsiz := int(binary.LittleEndian.Uint32(header_buf[4:8]))    // Filesize - 8 bytes 
    ftyp := string(header_buf[8:12])                            // File type header (just "WAVE")
    chnk := string(header_buf[12:16])                           // Format chunk marker (just "fmt ", space intentional)
    flen := int(binary.LittleEndian.Uint32(header_buf[16:20]))  // Format data length
    pcmf := int(binary.LittleEndian.Uint16(header_buf[20:22]))  // Type of format (1 = PCM)
    chnl := int(binary.LittleEndian.Uint16(header_buf[22:24]))  // Number of channels
    rate := int(binary.LittleEndian.Uint32(header_buf[24:28]))  // Sample rate (Hertz)
    nrte := int(binary.LittleEndian.Uint32(header_buf[28:32]))  // (SampleRate * BitsPerSample * Channels) / 8
    widt := int(binary.LittleEndian.Uint16(header_buf[32:34]))  // (BitsPerSample * Channels)/8
    btps := int(binary.LittleEndian.Uint16(header_buf[34:36]))  // Bits per sample 
    dhed := string(header_buf[36:40])                           // Data chunk header (just "data")
    dsiz := int(binary.LittleEndian.Uint32(header_buf[40:44]))  // Size of the data section

    fmt.Println(mark, fsiz, ftyp, chnk, flen, pcmf, chnl, rate, nrte, widt, btps, dhed, dsiz)

    data := make([]byte, fsiz)
    n, err = wavfile.ReadAt(data,43)


    num_samples := dsiz / nrte
    bytes_per_sample := btps/8
    samples := make([][]byte, num_samples)
    
    ptr := 0
    for i := 0; i < num_samples; i++ {

        samples[i] = data[ptr:(ptr+bytes_per_sample)]
        ptr += bytes_per_sample
    }

    for j := 0; j < num_samples; j++ {
        fmt.Println(samples[j])
    }
    

    
}
