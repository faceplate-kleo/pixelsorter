package main

import (
	f "github.com/faceplate-kleo/pixelsorter/lib/flags"
	psgif "github.com/faceplate-kleo/pixelsorter/lib/gif"
	"github.com/faceplate-kleo/pixelsorter/lib/nrgbautil"
	"github.com/faceplate-kleo/pixelsorter/src/core"

	"flag"
	"fmt"
)

func main() {
    inPath  := "./resources/skull2.png"
    outPath := "./out.png"
    maskInPath := "./mask.png"
    maskOutPath := "./mask.png"
    threshold := 110
    scalar := 2.0 
    noiseFactor := 0
    direction := "right"
    frames := 10
    wavein := ""
    framerate := 25
    buckets := 128

    flags := f.Flags{}

    flag.BoolVar(&flags.CRUSH, "crush", false, "Crush the output (bug turned feature)")
    flag.BoolVar(&flags.MASK_DEBUG, "mask_debug", false, "White-out the mask for debugging")
    flag.BoolVar(&flags.SOURCE_DEBUG, "source_debug", false, "Replace the input data with random color noise for debugging")
    flag.BoolVar(&flags.DEBUG, "span_debug", false, "Fill spans with random colors for debugging")
    flag.BoolVar(&flags.DESCEND, "descend", false, "Sort pixels in descending order")
    flag.BoolVar(&flags.CLEAN, "clean", false, "Limit sorting to only within mask, with no bleeding")
    flag.BoolVar(&flags.INVERT, "invert", false, "Invert the contrast mask")
    flag.BoolVar(&flags.MEAN_COMPARE, "mean_compare", true, "Base pixel comparisons on R+G+B/3")
    flag.BoolVar(&flags.GRAY_RED_COMPARE, "red_compare", false, "Base pixel comparions on just R - defaults false, overrides mean_compare")
    flag.StringVar(&inPath, "in", "", "Path to file to sort - REQUIRED")
    flag.StringVar(&outPath, "out", "./sorted.png", "Path to output file")
    flag.StringVar(&maskOutPath, "mask_out", "", "Path to mask output file - does not write if unspecified")
    flag.StringVar(&maskInPath, "mask", "", "Path to mask input file - skips mask generation step")
    flag.IntVar(&threshold, "threshold", 110, "Red channel threshold for the contrast mask")
    flag.StringVar(&direction, "direction", "right", "Direction of sort smear (up, down, left, right)")
    flag.Float64Var(&scalar, "scalar", 3.0, "Scale factor of sort span sizing")
    flag.IntVar(&noiseFactor, "noise", 0, "Random noise span offset amount in pixels")

    flag.BoolVar(&flags.ANIM, "anim", false, "Create a .gif animation")
    flag.BoolVar(&flags.WRITE_FRAMES, "write_frames", false, "Write all frames generated by -anim as individual .pngs. Omitting this option will generate a .GIF instead")
    flag.IntVar(&frames, "frames", 10, "The number of frames to generate when -anim is enabled")
    flag.StringVar(&wavein, "wav", "", "Filepath of a .wav file")
    flag.IntVar(&framerate, "framerate", 25, "Desired framerate of output .GIF (Warning: values n for 100 % n != 0 will cause time drift with audio!)")
    flag.IntVar(&buckets, "buckets", 128, "The number of frequency bands to divide .wav signal into")


    flag.Parse()

    if inPath == "" {
        fmt.Println("FATAL: no input file specified! ( -in )")
        flag.Usage()
        return
    }
    if !flags.ANIM {
        imData := nrgbautil.LoadImage(inPath)
        imData_nrgb := nrgbautil.DataToNrgba(imData, flags)
        sorted, mask := core.SortNrgbaImage(
                                imData_nrgb, 
                                threshold, 
                                scalar, 
                                noiseFactor, 
                                direction, 
                                maskInPath, 
                                nil, 
                                nil, 
                                flags,
                            )

        if maskOutPath != "" {
            nrgbautil.WriteFile(mask, maskOutPath)
        }
        nrgbautil.WriteFile(sorted, outPath)
    } else {
        imData := nrgbautil.LoadImage(inPath)
        imData_nrgb := nrgbautil.DataToNrgba(imData, flags)
        if wavein == "" {
            psgif.AnimationFromSingleFrame(
                    imData_nrgb, 
                    inPath, 
                    outPath, 
                    direction, 
                    threshold, 
                    noiseFactor, 
                    frames, 
                    scalar, 
                    flags,
                )
        } else {
            if inPath == "" {
                psgif.GifVisualization(wavein, "./visualization.gif", framerate, buckets)
            }
            core.WaveAnimationFromSingleFrame(
                    imData_nrgb, 
                    wavein, 
                    maskInPath, 
                    "./sorted.gif", 
                    direction, 
                    threshold, 
                    noiseFactor, 
                    framerate, 
                    buckets, 
                    scalar, 
                    flags,
                )
        }
    }   
}
